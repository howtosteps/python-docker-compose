{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is a starter tutorial on how to use docker-compose. Docker compose builds on Docker and provides the capability to define & run multiple container images. The configuration is read from a single docker-compose.yaml file which inturn is dependent on multiple DockerFile(s) and/or image(s) from the image repository. Compose works in all environments: production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application: Start, stop, and rebuild services View the status of running services Stream the log output of running services Run a one-off command on a service The key features of Compose that make it effective are: Have multiple isolated environments on a single host Preserves volume data when containers are created Only recreate containers that have changed Supports variables and moving a composition between environments Application components This application primarily consists of 3 parts - a simple web app file ( app.py ), dockerfile ( Dockerfile ) and the Docker Compose file ( docker-compose.yaml ). This start-up project will demonstrate how to use the compose tool, build container image(s) and then run the container in detached mode. Application structure |\u2500\u2500 docs # Contains edited nginx configuration file that will be copied to the image | \u251c\u2500\u2500 img # Contains all images referenced in mkdocs | \u251c\u2500\u2500 *.md # Other mkdocs .md files \u251c\u2500\u2500 mkdocs.yml # YAML for for mkdocs \u251c\u2500\u2500 .gitattributes | \u251c\u2500\u2500 Dockerfile # Dockerfile for the web-app \u251c\u2500\u2500 docker-compose.yaml # Configuration file for Compose tool \u251c\u2500\u2500 app.py # Simple web-based python program using Flask API \u251c\u2500\u2500 requirements.txt # List of packages to be pre-installed in the container \u251c\u2500\u2500 command-list.md # Cheat sheet for commands to run while running this simple tutorial \u251c\u2500\u2500 README.md # Standard README.md file References Docker Compose Overview","title":"Introduction"},{"location":"#introduction","text":"This is a starter tutorial on how to use docker-compose. Docker compose builds on Docker and provides the capability to define & run multiple container images. The configuration is read from a single docker-compose.yaml file which inturn is dependent on multiple DockerFile(s) and/or image(s) from the image repository. Compose works in all environments: production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application: Start, stop, and rebuild services View the status of running services Stream the log output of running services Run a one-off command on a service The key features of Compose that make it effective are: Have multiple isolated environments on a single host Preserves volume data when containers are created Only recreate containers that have changed Supports variables and moving a composition between environments","title":"Introduction"},{"location":"#application-components","text":"This application primarily consists of 3 parts - a simple web app file ( app.py ), dockerfile ( Dockerfile ) and the Docker Compose file ( docker-compose.yaml ). This start-up project will demonstrate how to use the compose tool, build container image(s) and then run the container in detached mode.","title":"Application components"},{"location":"#application-structure","text":"|\u2500\u2500 docs # Contains edited nginx configuration file that will be copied to the image | \u251c\u2500\u2500 img # Contains all images referenced in mkdocs | \u251c\u2500\u2500 *.md # Other mkdocs .md files \u251c\u2500\u2500 mkdocs.yml # YAML for for mkdocs \u251c\u2500\u2500 .gitattributes | \u251c\u2500\u2500 Dockerfile # Dockerfile for the web-app \u251c\u2500\u2500 docker-compose.yaml # Configuration file for Compose tool \u251c\u2500\u2500 app.py # Simple web-based python program using Flask API \u251c\u2500\u2500 requirements.txt # List of packages to be pre-installed in the container \u251c\u2500\u2500 command-list.md # Cheat sheet for commands to run while running this simple tutorial \u251c\u2500\u2500 README.md # Standard README.md file","title":"Application structure"},{"location":"#references","text":"Docker Compose Overview","title":"References"},{"location":"build-your-app/","text":"Start your app using docker-compose From your project directory, start up your application by running docker-compose up. Please note that we will use d flag to run the command in detached mode. C:\\Users\\aniru\\workspace\\docker\\python-docker-compose> docker-compose up -d As you can see, compose does the following : Compose pulls latest redis image from dockerhub Builds an image for your Dockerfile and binds it to exposed container port : 5000 Starts both the services you defined. In this case, the code is statically copied into the image at build time. You can now check the status of the containers with usual docker ps command. PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 205db680ecc6 python-docker-compose-web \"flask run\" 3 minutes ago Up 2 minutes 0.0.0.0:5000->5000/tcp python-docker-compose-web-1 92d7495e846d redis:alpine \"docker-entrypoint.s\u2026\" 3 minutes ago Up 2 minutes 6379/tcp python-docker-compose-redis-1","title":"Build your app"},{"location":"build-your-app/#start-your-app-using-docker-compose","text":"From your project directory, start up your application by running docker-compose up. Please note that we will use d flag to run the command in detached mode. C:\\Users\\aniru\\workspace\\docker\\python-docker-compose> docker-compose up -d As you can see, compose does the following : Compose pulls latest redis image from dockerhub Builds an image for your Dockerfile and binds it to exposed container port : 5000 Starts both the services you defined. In this case, the code is statically copied into the image at build time. You can now check the status of the containers with usual docker ps command. PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 205db680ecc6 python-docker-compose-web \"flask run\" 3 minutes ago Up 2 minutes 0.0.0.0:5000->5000/tcp python-docker-compose-web-1 92d7495e846d redis:alpine \"docker-entrypoint.s\u2026\" 3 minutes ago Up 2 minutes 6379/tcp python-docker-compose-redis-1","title":"Start your app using docker-compose"},{"location":"check-your-app/","text":"Run your app in your browser Enter http://localhost:5000/ on your browser. You should see Check inside the container Now that all is running fine. Let's check inside the container how it was built. We will use the container-id of the web-app container PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 205db680ecc6 python-docker-compose-web \"flask run\" 13 minutes ago Up 13 minutes 0.0.0.0:5000->5000/tcp python-docker-compose-web-1 92d7495e846d redis:alpine \"docker-entrypoint.s\u2026\" 13 minutes ago Up 13 minutes 6379/tcp python-docker-compose-redis-1 docker exec -it 205db680ecc6 /bin/sh PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker exec -it 205db680ecc6 /bin/sh /code # ls Dockerfile __pycache__ command-list.md docs requirements.txt README.md app.py docker-compose.yaml mkdocs.yml site /code # Notice that the workdir is set to /code as specified in the DockerFile Shutdown all the containers Let's shut it all down. docker-compose down PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker-compose down [+] Running 3/3 - Container python-docker-compose-redis-1 Removed 0.6s - Container python-docker-compose-web-1 Removed 1.2s - Network python-docker-compose_default Removed","title":"Check your app"},{"location":"check-your-app/#run-your-app-in-your-browser","text":"Enter http://localhost:5000/ on your browser. You should see","title":"Run your app in your browser"},{"location":"check-your-app/#check-inside-the-container","text":"Now that all is running fine. Let's check inside the container how it was built. We will use the container-id of the web-app container PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 205db680ecc6 python-docker-compose-web \"flask run\" 13 minutes ago Up 13 minutes 0.0.0.0:5000->5000/tcp python-docker-compose-web-1 92d7495e846d redis:alpine \"docker-entrypoint.s\u2026\" 13 minutes ago Up 13 minutes 6379/tcp python-docker-compose-redis-1 docker exec -it 205db680ecc6 /bin/sh PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker exec -it 205db680ecc6 /bin/sh /code # ls Dockerfile __pycache__ command-list.md docs requirements.txt README.md app.py docker-compose.yaml mkdocs.yml site /code # Notice that the workdir is set to /code as specified in the DockerFile","title":"Check inside the container"},{"location":"check-your-app/#shutdown-all-the-containers","text":"Let's shut it all down. docker-compose down PS C:\\Users\\aniru\\workspace\\github\\python-docker-compose> docker-compose down [+] Running 3/3 - Container python-docker-compose-redis-1 Removed 0.6s - Container python-docker-compose-web-1 Removed 1.2s - Network python-docker-compose_default Removed","title":"Shutdown all the containers"},{"location":"create-dockerfile/","text":"Create DockerFile We will now create a DockerFile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself. In the project directory, create a file named DockerFile FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0.0.0.0 COPY requirements.txt requirements.txt RUN pip install -r requirements.txt COPY . . CMD [\"flask\",\"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Copy requirements.txt and install the Python dependencies. Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run.","title":"Create Dockerfile"},{"location":"create-dockerfile/#create-dockerfile","text":"We will now create a DockerFile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself. In the project directory, create a file named DockerFile FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0.0.0.0 COPY requirements.txt requirements.txt RUN pip install -r requirements.txt COPY . . CMD [\"flask\",\"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Copy requirements.txt and install the Python dependencies. Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run.","title":"Create DockerFile"},{"location":"docker-compose/","text":"Configure services Create a file called docker-compose.yml in your project directory and paste the following: version: '3' services: web: build: . ports: - 5000:5000 volumes: - .:/code environment: - FLASK_ENV=development redis: image: redis:alpine This tells Compose tool to : Define 2 services - web and redis Web service - Use an image that\u2019s built from the Dockerfile in the current directory. It then binds the container and the host machine to the exposed port:5000. This example service uses the default port for the Flask web server: 5000. Redis service - Use public Redis image pulled from the Docker Hub registry. Set the version to 3","title":"Define Docker-Compose"},{"location":"docker-compose/#configure-services","text":"Create a file called docker-compose.yml in your project directory and paste the following: version: '3' services: web: build: . ports: - 5000:5000 volumes: - .:/code environment: - FLASK_ENV=development redis: image: redis:alpine This tells Compose tool to : Define 2 services - web and redis Web service - Use an image that\u2019s built from the Dockerfile in the current directory. It then binds the container and the host machine to the exposed port:5000. This example service uses the default port for the Flask web server: 5000. Redis service - Use public Redis image pulled from the Docker Hub registry. Set the version to 3","title":"Configure services"},{"location":"setup/","text":"Initial Setup 1. Create a directory All software assets will be created in this directory C:\\Users\\aniru\\workspace\\docker> mkdir python-docker-compose 2. Create application files 2.1 Create app.py file app.py is the main python file. redis is the hostname of the redis container that is expected to be running on a different container host. import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello hee haw ....again counter:{}\\n'.format(count) 2.2 Create requirements.txt Create and copy the following contents to requirements.txt . flask redis This will tell docker to pre-install these dependencies into the container. This is referenced in DockerFile as RUN pip install -r requirements.txt","title":"Setup"},{"location":"setup/#initial-setup","text":"","title":"Initial Setup"},{"location":"setup/#1-create-a-directory","text":"All software assets will be created in this directory C:\\Users\\aniru\\workspace\\docker> mkdir python-docker-compose","title":"1. Create a directory"},{"location":"setup/#2-create-application-files","text":"","title":"2. Create application files"},{"location":"setup/#21-create-apppy-file","text":"app.py is the main python file. redis is the hostname of the redis container that is expected to be running on a different container host. import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello hee haw ....again counter:{}\\n'.format(count)","title":"2.1 Create app.py file"},{"location":"setup/#22-create-requirementstxt","text":"Create and copy the following contents to requirements.txt . flask redis This will tell docker to pre-install these dependencies into the container. This is referenced in DockerFile as RUN pip install -r requirements.txt","title":"2.2 Create requirements.txt"}]}